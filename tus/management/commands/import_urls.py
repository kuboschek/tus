from __future__ import annotations

import csv

from django.core.management.base import BaseCommand
from django.db import transaction

from tus.utils.csvparser import CSVParser

from tus.models import ShortURL


class LinkParser(CSVParser):
    """ A CSVParser for Link """

    def __init__(self):
        super().__init__()
        self.register(['slug'], 'slug', self._parse_required)
        self.register(['source'], 'slug', self._parse_source)
        self.register(['target'], 'target', self._parse_required)
        self.register(['hits'], 'hits', self._parse_int)

    def _parse_required(self, value: str) -> str:
        if value == "":
            raise Exception("Missing required value")
        return value

    def _parse_source(self, value: str) -> str:
        if not (value.startswith('/') and value.endswith('/')):
            raise Exception("Source must start and end with '/'")
        return value[1:-1]

    def _parse_int(self, value: str) -> int:
        return int(value)


class Command(BaseCommand):
    help = 'Import a CSV of short urls'

    def add_arguments(self, parser) -> None:
        parser.add_argument(
            'files', nargs='*', help='Path to csv of urls to import ')
        parser.add_argument(
            '--columns',
            default='source,target,hits',
            help="Comma seperated list of fields to parse"
        )
        parser.add_argument(
            '--simulate',
            type=bool,
            help="Don't actually create any urls, just simulate creating them"
        )
        parser.add_argument(
            '--list-columns',
            action='store_true',
            dest='list_columns',
            help="List available columns and exit. "
        )

    def handle(self, *args, **kwargs) -> None:
        # create the parser and required arguments
        parser = LinkParser()
        required = ['slug', 'target']

        # list all columns if requested
        columns = kwargs['list_columns']
        if columns:
            return self.list_columns(parser, required, *args, **kwargs)

        # else do the import!
        return self.do_import(parser, required, *args, **kwargs)

    def list_columns(self, parser, required, *args, **kwargs):

        # fetch all available groups, and compute the maximum length
        groups = list(parser.groups())
        groups_len = max(map(lambda ct: len(ct[0]), groups))

        print("Available columns: ")
        for [column, targets] in groups:
            # add spacing for alignment
            column = column + " " * (groups_len - len(column))
            print("{}  (generated by {})".format(column, ",".join(targets)))

        print("")
        print("Required columns:")
        for r in required:
            print("{}".format(r))

    def do_import(self, parser, required, *args, **kwargs):
        # Find the file to parse
        files = kwargs['files']
        if len(files) != 1:
            raise Exception("expected exactly one file")

        # read the csv lines!
        lines = []
        with open(files[0], 'r') as f:
            # open the csv file and skip the first line
            reader = csv.reader(f)
            reader.__next__()

            # store the rest of the lines
            lines = list(reader)

        columns = kwargs['columns'].split(",")

        # parse the actual fields!
        parsed, targets = parser.parse(
            columns,
            lines,
            required=required,
        )

        simulate = kwargs['simulate']
        try:
            with transaction.atomic():
                # iterate over the users and create them, if they already exists, skip them!
                for url in parsed:
                    try:
                        surl = ShortURL.objects.create(
                            stats_enabled=True, **url)

                        print("Created ShortURL {}".format(surl.slug))
                    except Exception as e:
                        print("Could not create ShortURL {}: {}".format(person, e))
                        continue

                if simulate:
                    raise SimulateException()
        except SimulateException:
            print("--simulate was provided, rolling back changes")
            return


class SimulateException(Exception):
    pass
